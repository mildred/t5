// Copyright (c) 2009 Mildred Ki'Lya <http://ki.lya.online.fr>
//
// Permission is hereby granted, free of charge, to any person
// obtaining a copy of this software and associated documentation
// files (the "Software"), to deal in the Software without
// restriction, including without limitation the rights to use,
// copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the
// Software is furnished to do so, subject to the following
// conditions:
//
// The above copyright notice and this permission notice shall be
// included in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.

Section Header

  + name := STATE;

  - author        := "Mildred Ki'Lya <http://ki.lya.online.fr>";
  - copyright     := "2009 Mildred Ki'Lya";
  - comment       := "";

Section Inherit

  + parent :Expanded CLONABLE;

Section Public

  - read_token :TOKEN <-
  ( + in:INPUT_STREAM;
    + c:CHARACTER;
    + tk:TOKEN;
    + tk_grp:TK_GROUP;
    + tk_end_grp:TK_END_GROUP;
    + s:STRING;
    in := input_stream;
    in.read_character;

    in.end_of_input.if_false {
      c := in.last_character;
      (c = stack.current.char_escape).if {
        in.read_character;
        in.end_of_input.if {
          tk := TK_CHARACTER.clone.make (c);
        } else {
          s := STRING.create 128;
          s.add_last c;
          s.add_last (in.last_character);
          in.last_character.is_identifier.if {
            in.read_character;
            {(!in.end_of_input) && {in.last_character.is_identifier}}.while_do {
              s.add_last (in.last_character);
              in.read_character;
            };
            in.end_of_input.if_false {
              in.unread_character;
            };
          };
          tk := TK_IDENTIFIER.clone.make (s) name (s.substring (s.lower+1) to (s.upper));
        };
      }.elseif {c = stack.current.char_begin_group} then {
        tk_grp := TK_GROUP.clone.make (stack.current.char_begin_group,
                                       stack.current.char_end_group);
        stack.push_copy;
        tk_grp.install_in (stack.current);
        tk := read_token;
        {tk != NULL}.while_do {
          stack.current.output tk;
          ((tk_end_grp ?= tk) != NULL).if {
            // end group, stop loop
            tk := NULL;
          } else {
            tk := read_token;
          };
        };
        stack.pop;
        tk := tk_grp;
      }.elseif {c = stack.current.char_end_group} then {
        tk := TK_END_GROUP.clone.make c;
      }.elseif {c = stack.current.char_comment} then {
        s := STRING.create 128;
        s.add_last c;
        in.read_line_in s;
        {(!in.end_of_input) && {in.last_character.is_separator}}.while_do {
          s.add_last (in.last_character);
          in.read_character;
        };
        in.end_of_input.if_false {
          in.unread_character;
        };
        tk := TK_COMMENT.clone.make (s);
      } else {
        tk := TK_CHARACTER.clone.make (c);
      };
    };

    tk
  );

  + input_stream :INPUT_STREAM;

  + stack :STACK;

  + last_token :TOKEN;

  - make_input in:INPUT_STREAM stack s:STACK :SELF <-
  (
    input_stream := in;
    stack        := s;
    Self
  );

Section SELF

  - make_from origin:SELF <-
  (
    make_input (origin.input_stream) stack (origin.stack);
    last_token := origin.last_token;
  );

Section Public

  - process_token token:TOKEN <-
  ( + tk_idf:TK_IDENTIFIER;

    ((tk_idf ?= token) != NULL).if {
      + macro:MACRO;
      //
      // Read identifier (execute macro)
      //
      macro := stack.current.definitions.reference_at (tk_idf.name);
      (macro != NULL).if {
        macro.execute Self;
      } else {
        stack.current.output token;
      }
    } else {
      //
      // Read any other token and output it directly
      //
      stack.current.output token;
    };
  );

Section T5

  - process <-
  (
    last_token := read_token;
    (last_token != NULL).if {
      process_token last_token;
      process;
    };
  );


// kate: hl Lisaac v0.2; indent-width 2; space-indent on; replace-tabs on;
// kate: tab-width 8; remove-trailing-space on;
